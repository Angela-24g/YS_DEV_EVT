# j2735 규격에 따른 인코딩 데이터 분석

### 1. 문제
 - 의도: 인코딩 된 맵데이터와 새로 인코딩 생성하는 작업(기존 맵데이터를 가져와 인코딩하는 것)의 결과를 비교하여 일치하는지 확인
          - 현재 db에 저장된 데이터가 정확한 맵데이터인지를 확인하기 위한 작업

 - 문제 상황: 모든 교차로 데이터를 불러오고 형식에 맞춰 세팅 후 인코딩하는 작업이 시간이 너무 오래걸림(1개 생성하는데 16분 걸림)
 - 문제 원인
     1. 데이터가 총 4개 중 하나는 2800개, 하나는 53만개, 하나는 7만개, 하나는 2만개 - 그래서 하나 데이터 세팅하는데 시간이 걸림
     2. for문으로 기준이 되는 데이터를 매칭하여 데이터 세팅하는 작업이 시간이 걸림(for - if 구조여서 하나하나 분기 탐)
     3. 2에서 만든 데이터를 하나의 List로 저장하는데 있어서 heap memory가 부족함(만든 데이터가 용량이 너무 커서 어려움)

### 2. 해결점
- 1. 코드 변경
```bash
  List<String> result = new ArrayList<>();
  public getData(String newId) {
  for(Dto dto: List) {
      if(dto.id.equals(newId)) {
        return result.add(dto);
        }
    }
  }
```
 해당 구조는, list.iterator() 오버헤드, dto id 호출, null 체크, 분기를 여러 번 타서 실행을 하는 for문 구조로, 몇 십만개 하는 데이터를 모두 갖추기에는 CPU 할당이 굉장히 비효율적.

 여기서 필요한 점은, "JIT인라이닝 + Loop fusion"을 수행해야 함
    1. Loop fusion
     여러 개의 단계를 하나의 반복문으로 합쳐버리는 최적화하는 것
    2. JIT 인라이닝
     작고 자주 호출되는 메서드를 호출하지 않고, 그 자리에 코드를 직접 넣어 최적화하는 것

```bash
   import java.util.ArrayList;
// 1) Loop fusion
   List<String> list = new ArrayList<>();
    list.stream()
        .filter(x ->x >10)
        .map(x ->x *2)
        .toList();
    
// 2) JIT 인라이닝 
  list.stream().filter(x -> x.isActive());
```

- 2. 코드 결론
```bash
    private List<N2Dto> getNodes(DataDto Dto) {

        List<N2Dto> result = new ArrayList<>();
        List<N2Dto> collect = dataList.stream().filter(x -> x.getId().equals(Dto.getId()) && x.getTwId().equals(Dto.getTwId()))
                                               .collect(Collectors.toList());
        result = collect;
        return result; 
    }
```

- 3. 총정리
```
| 항목                       | **for-loop**                                  | **Stream / 람다**                            |
| ------------------------ | --------------------------------------------- | ------------------------------------------ |
| **기본 구조**                | 외부 반복(external iteration)                     | 내부 반복(internal iteration)                  |
| **성능(작은 데이터)**           | 더 빠름(오버헤드 거의 없음)                              | 느릴 수 있음(파이프라인+람다 오버헤드)                     |
| **성능(중간~큰 데이터)**         | 일정 패턴이면 빠름                                    | JIT 최적화 잘 터지면 **더 빠를 수도 있음**               |
| **branch 수**             | 많음 (if + add 내부 branch) → misprediction 발생 가능 | JIT가 branch 줄이거나 예측 잘 되도록 최적화 가능           |
| **loop fusion 가능성**      | 없음 (개발자가 직접 합쳐야 함)                            | 있음. filter/map/collect 단계가 **하나의 루프로 통합**  |
| **JIT inlining 최적화**     | 제한적 (특히 list.get, iterator, bounds check 남음)  | 람다 함수 인라이닝 잘 됨 → 호출 비용 사실상 0               |
| **iterator 사용 여부**       | for-each는 iterator 사용 → 오버헤드 존재               | Stream은 자체 iteration으로 최적화됨                |
| **중간 컬렉션 생성**            | 개발자가 따로 만들면 생성됨                               | JIT 최적화 시 대부분 **중간 컬렉션 없이** fused loop로 처리 |
| **병렬 처리**                | 직접 쓰레드 관리해야 함                                 | `parallelStream()` 한 줄로 병렬화 (대용량에서 매우 유리)  |
| **실제 사용 시 주의점**          | 조건 많아지면 branch가 늘어 성능 나빠짐                     | 작은 컬렉션에서는 오히려 느릴 수 있음                      |
| **메모리 사용량**              | 거의 없음                                         | Stream pipeline 객체가 생성되어 소량 증가             |
| **최고 성능 조건**             | 단순 반복 + 작은 데이터                                | filter/map 조합 + 데이터 양 중간 이상 + JIT 최적화 성공   |
| **실제 체감 예시**             | 실시간, 단순 루프에서 강함                               | 데이터 처리 스트림에서 강함                            |
```